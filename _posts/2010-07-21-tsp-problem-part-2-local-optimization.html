---
layout: post
title: TSP Problem - Part 2 - Local Optimization and Meta Heuristics
date: '2010-07-21T09:07:00.000-07:00'
author: Wizche
tags: 
modified_time: '2010-07-21T09:07:36.726-07:00'
thumbnail: http://1.bp.blogspot.com/_cXYmdFluLpw/TEcXtmQRaSI/AAAAAAAAAkU/yjah1wUxCIM/s72-c/algorithm_results.PNG
blogger_id: tag:blogger.com,1999:blog-6991263519641111952.post-5685503039726369593
blogger_orig_url: http://blog.wizche.ch/2010/07/tsp-problem-part-2-local-optimization.html
---

Back with the last part of TSP problem, if you missed the first one you can find it <a href="http://blog.wizche.ch/2010/04/tsp-problem-part-1-construction.html">here</a>.<br /><br />The TSP competition ended up in June, and I finished in third position. As you may have noticed in the results table, there is a couple of problem which where hard to lower, especially the u1060. <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_cXYmdFluLpw/TEcXtmQRaSI/AAAAAAAAAkU/yjah1wUxCIM/s1600/algorithm_results.PNG" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="344" src="http://1.bp.blogspot.com/_cXYmdFluLpw/TEcXtmQRaSI/AAAAAAAAAkU/yjah1wUxCIM/s640/algorithm_results.PNG" width="640" /></a></div><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Let's see some code...<br /><b>2OPT:</b><br /><pre class="cpp" name="code">// Take a tour array<br />// Return running time<br />double twoOpt(int *tour) {<br /> clock_t start, end;<br /><br /> if (LOG) {<br />  fprintf(debfp, "2 Opt local optimization...\n");<br /> }<br /> if (DEBUG)<br />  printf("2 Opt local optimization...\n");<br /><br /> start = clock();<br /><br /> int bestGain = INT_MAX;<br /> int best_i;<br /> int best_j;<br /> int gain;<br /> double ct = 0.0;<br /> int count = 0;<br /> // Continue until no improvements are possible<br /> while (bestGain != 0) {<br />  bestGain = 0;<br />  for (int i = 1; i &lt; dimension; i++) {<br />   int j = i + 2;<br />   for (; j &lt; dimension; j++) {<br />    gain = compute_gain(tour, i, j);<br />    // Search for the biggest gain<br />    if (gain &lt; bestGain) {<br />     bestGain = gain;<br />     best_i = i;<br />     best_j = j;<br />    }<br />   }<br />  }<br />  count++;<br /><br />  if (DEBUG2OPT)<br />   printf("Best optimization %d-&gt;%d and %d-&gt;%d = %d\n", tour[best_i],<br />     tour[best_i + 1], tour[best_j], tour[best_j + 1], bestGain);<br /><br />  if (LOG) {<br />   fprintf(debfp, "Best optimization %d-&gt;%d and %d-&gt;%d = %d\n",<br />     tour[best_i], tour[best_i + 1], tour[best_j], tour[best_j<br />       + 1], bestGain);<br />  }<br /><br />  if (bestGain != 0) {<br />   if (DEBUG2OPT)<br />    printf("SWAP");<br /><br />   // Swap cities<br />   swap(tour, best_i + 1, best_j);<br />   // Reverse path<br />   reverseArray(tour, best_i + 1, best_j);<br />  }<br /> }<br /><br /> end = clock();<br /> ct = ((end - start) / ((double) CLOCKS_PER_SEC)) * 1000.0;<br /> return ct;<br />}<br /></pre><br /><br /><b>Simulated Annealing:</b><br /><pre class="cpp" name="code">int *simulatedAnnealing(int *tour, int remainingMS, int startTemp,<br />  double delta, int iteration) {<br /> int *current = (int *) calloc(sizeof(int), dimension + 2);<br /> int *best = (int *) calloc(sizeof(int), dimension + 2);<br /> int *next = (int *) calloc(sizeof(int), dimension + 2);<br /><br /> clock_t start, end;<br /><br /> current = tour;<br /> next = tour;<br /> best = current;<br /> double temp = startTemp;<br /> int diff = 0;<br /><br /> int iter = iteration;<br /> if(randomSeed==0)<br />   randomSeed = time(NULL);<br /> <br /> srand(randomSeed);<br /><br /> double random = 0.0;<br /> int lenNext = 0;<br /> int lenCurrent = 0;<br /> int lenBest = length(current);<br /><br /> if (DEBUGSA) {<br />  printf("SA: Random seed: %d\n Remaining time: %d\n", randomSeed, remainingTime);<br /> }<br /><br /> while (temp &gt; 0 &amp;&amp; remainingMS &gt; 0) {<br /><br />  while (iter &gt; 0) {<br />   // Start clock<br />   start = clock();<br />   next = doubleBridge(current); // Diversification<br />   twoOpt(next); // Intensification<br />   lenNext = length(next);<br />   lenCurrent = length(current);<br />   diff = lenNext - lenCurrent;<br /><br />   if (DEBUGSA) {<br />    printf("SA: Difference between next[%d] and current[%d] = %d\n", lenNext, lenCurrent, diff);<br />   }<br /><br />   if (diff &lt; 0) {<br />    current = next;<br />    if(lenNext &lt; lenBest)<br />    {<br />     if(tourCheck(next, lenNext))<br />     {<br />      if(lenNext &lt; bestknown)<br />      {<br />       printf("Stopped something wrong!");<br />       getchar();<br />      }<br />      copy(next, best, dimension + 2);<br />      printf("*** NEW BEST: %d\n", lenNext);<br />      lenBest = lenNext;<br />     } else<br />     {<br />      printf("Wrong tour!\n");<br />     }<br /><br />    }<br />   } else {<br />    random = (rand() / ((double)RAND_MAX));<br />    if (DEBUGSA) {<br />     printf("SA: Generated random: %2.3f\n", random);<br />    }<br />    // Stochastic decision<br />    if (random &lt; exp(-diff / temp)) {<br />     // current = next<br />     if (DEBUGSA) {<br />      printf("Current = next");<br />     }<br />     copy(next, current, dimension + 2);<br />    } else {<br />     // keep current<br />    }<br />   }<br />   // Compute remaining time<br />   end = clock();<br />   remainingMS -= (((end - start) / ((double) CLOCKS_PER_SEC))<br />     * 1000.0);<br /><br />   iter--;<br />  }<br />  iter = iteration;<br />  temp = temp * delta;<br /> }<br /> return best;<br />}<br /></pre><a href="http://sites.google.com/site/wizche/AlgorithmCup2010.zip?attredirects=0&amp;d=1">You may download the whole source (with his Makefile) here.</a> &nbsp;<br />Enjoy