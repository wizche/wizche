---
layout: post
title: TSP Problem - Part 1 - Construction Algorithm - Nearest Neighbour
date: '2010-04-11T08:09:00.000-07:00'
author: Wizche
tags:
- tsp algorithm programming
modified_time: '2010-04-11T08:43:29.637-07:00'
thumbnail: http://2.bp.blogspot.com/_cXYmdFluLpw/S8HlYOGaxaI/AAAAAAAAAi4/BvVPLAMI6b8/s72-c/nn_result.png
blogger_id: tag:blogger.com,1999:blog-6991263519641111952.post-1791201784027465923
blogger_orig_url: http://blog.wizche.ch/2010/04/tsp-problem-part-1-construction.html
---

Many of you have certainly heard about the TSP problem (<a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">Travelling Salesman Problem</a>).<br />His target is to find the shortest tour that visits every city (just once) and return to the start city...<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://imgs.xkcd.com/comics/travelling_salesman_problem.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://imgs.xkcd.com/comics/travelling_salesman_problem.png" /></a></div><div style="text-align: center;"><span style="font-size: x-small;"><i>From xkcd.com ( <a href="http://xkcd.com/399/">http://xkcd.com/399/</a> )</i></span></div><br />For the algorithm class we had the excercise ("Algorithm Cup") to try out the best solution we could find on 10 TSP problems (from the <a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/">TSPLIB</a>). We have some restriction too, the algorithm has to run on a "simple machine" (duo-core) and has a time limit of 3 minutes for each instance (for each problem).<br /><br />Considering I've not much time, I choose this approach for implementing my solution:<br />1) Construction algorithm:<a href="http://en.wikipedia.org/wiki/Nearest_neighbour_algorithm"> Nearest Neighbour&nbsp;</a><br />2) Local optimization: 2/2.5 - OPT (<a href="http://www-e.uni-magdeburg.de/mertens/TSP/node3.html">web simulation applet</a>)<br />3) Meta-Heuristics: <a href="http://en.wikipedia.org/wiki/Simulated_Annealing">Simulated Annealing</a><br /><br />My expectation (error from the optimal solution) for the above algorithms (depending on the problem):<br />1) Around 21-26 % <br />2) Around 4-8%<br />3) Lower than 1%<br /><br />Let's start coding (in C), as data structure I choose the simplest (and fastest) possible: array of integer.<br />First we need to parse the TSPLIB problem files (.tsp) and construct our distances[][] array, my decision was to keep exactly the same numbering of cities from the problem as index of all my arrays.<br /><br />For example distances[1][2] give me the distance from city one to city two.<br /><br />I keep my actual tour in an array named tour[] and I used to pass this to my functions where I've implemented the algorithms.<br /><br /><b>Construction Algorithm: Nearest Neighbour</b><br /><pre class="cpp" name="code">// Compute Nearest Neighbour<br />// Return running time in ms<br />double nearestNeighbour(int *_cityPath)<br />{<br /> clock_t start, end;<br /> <br /> if(DEBUG)<br />  printf("Nearest Neighbour construction...\n");<br /><br /> // Start clock<br /> start = clock();<br /><br /> // Allocate an "already visited" array (the +1 is cause I start my array from index 1)<br /> bool *visited = (bool *) calloc(sizeof(bool), dimension+1);<br /> // Start from city one<br /> int cityVisited = 1;<br /> <br /> int minPath = INT_MAX;<br /> int *cityPath = _cityPath;<br /> int ii = 1;<br /> int j;<br /> int minPathCity = 0;<br /> <br /> // Iterate all cities <br /> while(cityVisited &lt;= dimension)<br /> {<br />  if(DEBUG)<br />   printf("Searching neighbor of %d [total: %3d]\n", ii, cityVisited);<br />  // Iterate through all cites near ii<br />  for(j=1; j&lt;=dimension;j++)<br />  {<br />   // if distance from city ii to j is lower then the minPath <br />   if(distances[ii][j] &lt; minPath)<br />   {<br />    // if I've not already choose the city<br />    if(!visited[j])<br />    {<br />     // replace the minPath<br />     minPath = distances[ii][j];<br />     minPathCity = j;<br />     //printf("New neighbor for %3d: %3d\n", ii, j);<br />    }<br />   }<br />  }<br />  // set <br />  cityPath[cityVisited] = ii;<br />  // set ii as already visited<br />  visited[ii] = true;<br />  // ii is the next city<br />  ii = minPathCity;<br />  // reset minPath to INT_MAX for the next round<br />  minPath = INT_MAX;<br />  // increment cityVisited counter<br />  cityVisited++;<br /> }<br /> // Add retour to the first city<br /> cityPath[cityVisited] = cityPath[1];<br /><br /> // Compute running time of NN algorithm<br /> end = clock();<br /> double ct =((end-start)/ ((double)CLOCKS_PER_SEC)) * 1000.0;<br /> return ct;<br />}<br /></pre><br />Now let's see how it work on a 1577 cities TSP problem (fl1577.tsp)<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_cXYmdFluLpw/S8HlYOGaxaI/AAAAAAAAAi4/BvVPLAMI6b8/s1600/nn_result.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="243" src="http://2.bp.blogspot.com/_cXYmdFluLpw/S8HlYOGaxaI/AAAAAAAAAi4/BvVPLAMI6b8/s640/nn_result.png" width="640" /></a></div><br />In the part two we will se how local optimization can improve this tour...<br /><br />Keep tuned!