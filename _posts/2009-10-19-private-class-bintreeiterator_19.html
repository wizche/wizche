---
layout: post
title: Java - Binary Tree Iterator for in-order traversal (iterative)
date: '2009-10-19T10:19:00.001-07:00'
author: Wizche
tags:
- tree traversal
- algorithm
- binary tree
- java
modified_time: '2009-10-19T10:51:34.761-07:00'
blogger_id: tag:blogger.com,1999:blog-6991263519641111952.post-1191108873425930968
blogger_orig_url: http://blog.wizche.ch/2009/10/private-class-bintreeiterator_19.html
---

I had so much trouble implementing an iterator who traverses my tree using in-order traversal in an iterative way.<br /><br />Here below the solution who came up thanks to <span style="font-weight: bold;">Ivano </span>and Fabio.<br /><br />Hope it can helps.<br /><br /><a href="http://sergio.paganoni.googlepages.com/BinaryTree.java">The complete code of BinaryTree is available here</a> (use at your own risk)<br /><br /><br /><pre class="Cpp" name="code"><br /> private class BinTreeIterator implements Iterator<T>{<br />  <br /><br />        private Node p;<br />        private boolean complete;<br /><br />        public BinTreeIterator(Node root) {<br />                p = root;<br />                complete = false;<br />                setNotVisitedNode(root);<br /><br />                // set p to the smallest element of the tree<br />                while (p.getLeftChild() != null)<br />                        p = p.getLeftChild();<br />        }<br /><br />        private void setNotVisitedNode(Node n) {<br />                if (n.getLeftChild() != null)<br />                        setNotVisitedNode(n.getLeftChild());<br />                n.visited = false;<br />                if (n.getRightChild() != null)<br />                        setNotVisitedNode(n.getRightChild());<br />                  n.getRightChild();<br />        }<br /><br />        public boolean hasNext() {<br />                return !complete;<br />        }<br /><br />        public T next() {<br />                // check if completed<br />                if(complete)<br />                        return null;<br /><br />                Node tmp = p;<br />                p.setVisited(true);<br /><br />                // next node to visit<br />                if (p.getLeftChild() != null && !p.getLeftChild().isVisited())<br />                {<br />                        // set p to the smallest element of the tree<br />                        while (p.getLeftChild() != null && !p.getLeftChild().isVisited())<br />                                p = p.getLeftChild();<br />                }<br />                else if (p.getRightChild() != null && !p.getRightChild().isVisited())<br />                {<br />                        p = p.getRightChild();<br />                        // set p to the smallest element of the tree<br />                        while (p.getLeftChild() != null && !p.getLeftChild().isVisited())<br />                                p = p.getLeftChild();<br />                }<br />                else {<br />                        // sub tree completed, step back or quit<br />                        while(p!=null && p.isVisited())<br />                                p=p.getParent();<br />                        // check for root<br />                        if (p==null)<br />                                complete=true;<br />                }<br />                // return current visited node<br />                return tmp.getValue();<br />        }<br /><br />        public void remove() {<br /><br />        } <br />  <br /> }<br /><br /></pre>